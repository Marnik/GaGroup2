package cifo;

import java.text.DecimalFormat;
import java.util.HashMap;
import java.util.Random;

public class GeneticAlgorithm extends SearchMethod {

	protected ProblemInstance instance;
	protected int populationSize, numberOfGenerations;
	protected double mutationProbability;
	protected int tournamentSize;
	protected boolean printFlag;
	protected Solution currentBest;
	protected int currentGeneration;
	protected Solution[] population;
	protected Random r;

	public GeneticAlgorithm() {
		instance = new ProblemInstance(Main.NUMBER_OF_TRIANGLES);
		populationSize = Main.POPULATION_SIZE;
		numberOfGenerations = Main.NUMBER_OF_GENERATIONS;
		mutationProbability = Main.MUTATION_PROBABILIY;
		tournamentSize = Main.TOURNAMENT_SIZE;
		printFlag = false;
		currentGeneration = 0;
		r = new Random();
	}

	public void run() {
		double startTime = System.currentTimeMillis();
		initialize();
		evolve();
		double endTime = System.currentTimeMillis();
		double executionTime = (endTime - startTime) / 60000;
		Main.addBestSolution(currentBest, executionTime);
	}

	public void initialize() {
		population = new Solution[populationSize];
		for (int i = 0; i < population.length; i++) {
			population[i] = new Solution(instance);
			population[i].evaluate();
		}
		updateCurrentBest();
		updateInfo();
		currentGeneration++;
	}

	public void updateCurrentBest() {
		currentBest = getBest(population);
	}

	public void evolve() {
		while (currentGeneration <= numberOfGenerations) {
			Solution[] offspring = new Solution[populationSize];
			for (int k = 0; k < population.length; k++) {
				//int[] parents = selectParents();
				int[] parents = rouletteSelection();

				offspring[k] = applyCrossover(parents);
				if (r.nextDouble() <= mutationProbability) {
					offspring[k] = offspring[k].applyMutation();
				}
				offspring[k].evaluate();
			}

			population = survivorSelection(offspring);
			updateCurrentBest();
			updateInfo();
			currentGeneration++;
		}
	}

	// Method to select parents using the tournament selection method
	public int[] selectParents() {
		int[] parents = new int[2];
		parents[0] = r.nextInt(populationSize);
		for (int i = 0; i < tournamentSize; i++) {
			int temp = r.nextInt(populationSize);
			if (population[temp].getFitness() < population[parents[0]].getFitness()) {
				parents[0] = temp;
			}
		}

		parents[1] = r.nextInt(populationSize);
		for (int i = 0; i < tournamentSize; i++) {
			int temp = r.nextInt(populationSize);
			if (population[temp].getFitness() < population[parents[1]].getFitness()) {
				parents[1] = temp;
			}
		}
		return parents;
	}

	// Method to select parents using the roulette wheel selection method
	private int[] rouletteSelection() {
		int[] parents = new int[2];
		double totalFitness = 0.0;
		HashMap<Integer, Double> rouletteWheel = new HashMap<Integer, Double>();
		HashMap<Integer, Double> invertedRouletteWheel = new HashMap<Integer, Double>();

		// Get the total fitness of the population
		for (int i = 0; i < populationSize; i++) {
			totalFitness += population[i].getFitness();
		}

		double cumProb = 0.0;
		// Assign a cumulative (0-1) value to each individual, depending on its
		// fitness.
		for (int i = 0; i < populationSize; i++) {
			// We want to compute probabilities from 0 to 1 first for each
			// individual and save them. We subtract the found probability
			// from 1 and will compute the fitness later on with these values.
			// This is because we're facing a minimization problem, not a
			// maximization.
			rouletteWheel.put(i, 1 - (population[i].getFitness() / totalFitness));
		}

		// We want to repeat the process for found probabilities. This time
		// we'll assign the cumulative probabilities.
		totalFitness = 0.0;
		for (double d : rouletteWheel.values()) {
			totalFitness += d;
		}

		for (int i = 0; i < populationSize; i++) {
			if (i == 0) {
				invertedRouletteWheel.put(i, rouletteWheel.get(i) / totalFitness);
			}
			else{
				invertedRouletteWheel.put(i, (rouletteWheel.get(i) / totalFitness) + invertedRouletteWheel.get(i-1));
			}
		}
		
		// Spin the roulette wheel
		Random r = new Random();
		double randomDouble = 1.0 * r.nextDouble();
		
		// Loop through the HashMap containing the probabilities and select the right individual.
		
		for(int i = 0; i < populationSize; i++){ // Consider changing this to an iterator
			if(randomDouble < invertedRouletteWheel.get(i)){
				parents[0] = i;
				break;
			}
		}
		
		Random r2 = new Random();
		double randomDouble2 = 1.0 * r2.nextDouble();
		
		for(int i = 0; i < populationSize; i++){ // Consider changing this to an iterator
			if(randomDouble2 < invertedRouletteWheel.get(i)){
				parents[1] = i;
				break;
			}
		}
		
		return parents;
	}

	public Solution applyCrossover(int[] parents) {
		Solution firstParent = population[parents[0]];
		Solution secondParent = population[parents[1]];
		Solution offspring = firstParent.copy();
		int crossoverPoint = r.nextInt(instance.getNumberOfTriangles() * Solution.VALUES_PER_TRIANGLE);
		for (int i = crossoverPoint; i < instance.getNumberOfTriangles() * Solution.VALUES_PER_TRIANGLE; i++) {
			offspring.setValue(i, secondParent.getValue(i));
		}
		// Loop through triangles
		for(int i = 0; i < instance.getNumberOfTriangles() * Solution.VALUES_PER_TRIANGLE; i += Solution.VALUES_PER_TRIANGLE){
			System.out.println(offspring.getValue(i));
		}
		
		return offspring;
	}

	public Solution[] survivorSelection(Solution[] offspring) {
		Solution bestParent = getBest(population);
		Solution bestOffspring = getBest(offspring);
		if (bestOffspring.getFitness() <= bestParent.getFitness()) {
			return offspring;
		} else {
			Solution[] newPopulation = new Solution[population.length];
			newPopulation[0] = bestParent;
			int worstOffspringIndex = getWorstIndex(offspring);
			for (int i = 0; i < newPopulation.length; i++) {
				if (i < worstOffspringIndex) {
					newPopulation[i + 1] = offspring[i];
				} else if (i > worstOffspringIndex) {
					newPopulation[i] = offspring[i];
				}
			}
			return newPopulation;
		}
	}

	public Solution getBest(Solution[] solutions) {
		Solution best = solutions[0];
		for (int i = 1; i < solutions.length; i++) {
			if (solutions[i].getFitness() < best.getFitness()) {
				best = solutions[i];
			}
		}
		return best;
	}

	public int getWorstIndex(Solution[] solutions) {
		Solution worst = solutions[0];
		int index = 0;
		for (int i = 1; i < solutions.length; i++) {
			if (solutions[i].getFitness() > worst.getFitness()) {
				worst = solutions[i];
				index = i;
			}
		}
		return index;
	}

	public void updateInfo() {
		currentBest.draw();
		series.add(currentGeneration, currentBest.getFitness());
		if (printFlag) {
			System.out.printf("Generation: %d\tFitness: %.1f\n", currentGeneration, currentBest.getFitness());
		}
	}
}
